## 条款33：避免遮掩继承而来的名称

​			***Avoid hiding inherited names***

与作用域（scopes）有关：

```c++
int x;		//global变量
void someFunc()
{
	double x;	//local变量
	std::cin>>x;	//读一个新值赋予local变量x
}
```

因为内层作用域的名称会遮掩外围作用域的名称：

<img src="C:\Users\Joerside\AppData\Roaming\Typora\typora-user-images\image-20220919153741610.png" alt="image-20220919153741610" style="zoom: 50%;" />

现在导入继承：derived class继承了声明于base classes内的所有东西，实际运作方式是derived class作用域被嵌套在base class作用域内：

```c++
class Base{
private:
	int x;
public:
	virtual void mf1()=0;
	virtual void mf2();
	void mf3();
	...
};
class Derived:public Base{
public:
	virtual void mf1();
	void mf4();
	...
};
```

<img src="https://cdn.staticaly.com/gh/Jayttle/typora_img@main/img/202209191546486.png" alt="image-20220919154605449" style="zoom: 67%;" />

重要的名称是什么，而不是其他；

这次我们重载mf1和mf3，并添加一个新版mf3到derived去：

你可以使用using 声明式达到目标：

```c++
class Base{
private:
	int x;
public:
	virtual void mf1()=0;
	virtual void mf1(int);
	virtual void mf2();
	void mf3();
	void mf3(double);
	...
};
class Derived:public Base{
public:
	using Base::mf1;	//让Base class内名为mf1和mf3的所有东西
	using Base::mf3;	//在Derived作用域内都可见（并且public）
	virtual void mf1();
	void mf3();
	void mf4();
}
```

<img src="https://cdn.staticaly.com/gh/Jayttle/typora_img@main/img/202209191558551.png" alt="image-20220919155814511" style="zoom:67%;" />

```c++
Derived d;
int x;
...
d.mf1();		//仍然没问题，仍调用Derived::mf1
d.mf1(x);		//现在没问题，是Base::mf1
d.mf2();		//仍然没问题，仍调用Base::mf2
d.mf3();		//没问题，调用Derived::mf3
d.mf3(x);		//现在没问题，调用Base::mf3
```

```c++
//若没有using Base::mf1;
//则d.mf1(X)会不记得调用原本在Base class有的函数（因为已经被derived class的mf1覆盖并报错了）
```

显然，public继承不怎么合适，选择private（条款39）可能有意义，并使用一个简单的转交函数（forwading function）：

```c++
class Base{
public:
	virtual void mf1=0;
	virtual void mf1(int);
	...
};
class Derived:private Base{
public:
	virtual void mf1()		//转交函数（forwading function）
	{	Base::mf1();	}	//暗自成为inline（条款30）
	...
};
...
Derived d;
int x;
d.mf1();	//调用的是Derived::mf1
d.mf1(x);	//error!Base::mf1()被遮掩了
```

**请记住：**

+ derived classes内的名称会遮掩base classes内的名称。在public 继承下从来没有人希望如此
+ 为了让被遮掩的名称再见天日，可使用using 声明式or转交函数（forwarding functions）；