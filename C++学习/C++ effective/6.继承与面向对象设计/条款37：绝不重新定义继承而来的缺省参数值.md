## 条款37：绝不重新定义继承而来的缺省参数值

​		***Never redefine a function's inherited fault parameter value***

​	你只能继承并重新定义的只有virtual函数；（条款36 non-virtual不能重定义）

​	理由：virtual函数系动态绑定（dynamically bound），而缺省参数值却是静态绑定（statically bound）；

​	（静态绑定又称前期绑定，early binding，动态绑定又称为后期绑定，late binding）

考虑：

```c++
class Shape{
public:
	enum ShapeColor{Red,Green,Blue}
	//所有形状都必须有一个函数，用来描绘出自己
	virtual void draw(ShapeColor color=Red) const =0;
}
class Rectangle:public Shape{
public:
	//注意。赋予不同的缺省参数值，这真糟糕！
	virtual void draw(ShapeColor color=Green) const;
	...
};
class Circle:public Shape{
public:
	virtual void draw(ShapeColor color) const;
    //请注意：以对象调用此函数，一定要指定参数值
    //	静态绑定下这个函数并不从其base继承缺省参数值
    //	若以指针（reference）调用此函数，可以不指定参数值；
    //	因为动态绑定会从其base继承缺省参数值
}
```

同时，也没必要重新对继承class的默认参数赋值：

```c++
class Shape{
public:
	enum ShapeColor{Red,Green,Blue}
	virtual void draw(ShapeColor color=Red) const =0;
	...
};
class Rerctangle:public Shape{
public:
	virtual void draw(ShapeColor color=Red) const;
	...
};
```

代码重复又带着相依性（with dependencies）；

如果Shape内的缺省参数值改变了，所有derived class的也要改变；

​	因此使用条款35列举的不少virtual函数替代设计：

​	NVI（non-virtual interface）手法：令base class内的一个public non-virtual函数调用private virtual函数，后者可被derived class重新定义：

```c++
class Shape{
public:
	enum ShapeColor{ Red,Green,Blue	};
	void draw(ShapeColor color=Red) const	//如今它是non-virtual
	{
		doDraw(color);				//调用一个virtual；
	}
	...
private:
	virtual void doDraw(ShapeColor color) const=0;
};
class Rectangle: public Shape{
public:
	...
private:
	virtual void doDraw(ShapeColor color) const;	//注意，不需要指定缺省参数值；
	...
}
```

#### 请记住：

+ 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定；