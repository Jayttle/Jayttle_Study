## 条款34：区分接口继承和实现继承	

***Differentiate between inheritance of interface and inheritance of implementation***

public继承概念由：函数接口（function interfaces）继承和函数实现（function implementations）组成；

**三种情况：**

+ derived classes 只继承成员函数的接口（就是声明）
+  derived classes同时继承函数的接口和实现，又能覆写（override）所继承的实现；
+ derived classes继承函数的接口和实现而不覆写

假设：一个展现绘图程序中各种几何形状的class继承体系：

```c++
class Shape{
public:
	virtual void draw() const=0;
	virtual void error(const std::string& msg);
	int objectID() const;
	...
};
class Rectangle:public Shape{...};
class Ellipse:public Shape{...};
```

因为Shape是个抽象类，pure virtual函数draw 使它成为一个抽象class，客户无法创建shape class的实体；

+ 声明一个pure virtual函数的目的是为了让derived classes只继承函数接口

+ 声明简朴的（非纯）impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现；

```c++
class Shape{
public:
    virtual void error(const std::string& msg);
    ...
};
```

Shape::error的声明式告诉设计者：必须支持一个error函数，否则使用Shape class的缺省版本；

但是，允许impure virtual函数同时指定函数声明和函数缺省行为，会可能造成危险：

```c++
class Airplane{
public:
	virtual void fly(const Airport& destination)=00;
	...
};

void Airplane::fly(const Airport& destination)	//pure virtual 函数实现
{
	缺省行为，将飞机飞至指定的目的地
}
class ModelA:public Airplane{
public:
	virtual void fly(const Airport& destination)
	{	Airplane::fly(destination);	}
	...
};
class ModelB:public Airplane{
public:
	virtual void fly(const Airport& destination)
	{	Airplane::fly(destination);}
	...
};
class ModelC:public Airplane{
public:
	virtual void fly(const Airport& destination);
	...
};
void ModelC::fly(const Airport& destination)
{
	将C型飞机飞至指定的目的地
}
```

将独立函数Airplane::defaultFly替换了pure virtual函数Airplane::fly。可以将fly被分割成两个基本要素：其声明部分表现的是接口，定义部分则表现出缺省行为；

+ 声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现；

pure virtual函数、simple（impure）virtual 函数、non-virtual函数差异：

只继承接口，or 继承接口和一份缺省实现，or 继承接口和一份强制实现；

**请记住：**

+ 接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口
+ pure virtual 函数只具体指定接口继承
+ 简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承
+ non-virtual函数具体指定接口继承以及强制实现继承；