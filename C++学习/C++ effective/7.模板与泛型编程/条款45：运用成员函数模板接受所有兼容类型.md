## 条款45：运用成员函数模板接受所有兼容类型

​			***Use member function templates to accept"all compatible types"***

同一个template的不同具体现（instantiations）之间不存在什么与生俱来的故有关系（指有base-derived关系的B，D两类型分别具现化某个template而不带有base-derived关系）

member function templates（简称为member templates），其作用为class生成函数：

```c++
template<typename T>
class SmartPtr{
public:
	template<typename U>				//member template
	SmartPtr(const SmartPtr<U>& other);	//为了生成copy构造函数
    ...
}
```

 这一类构造函数根据对象u创建对象t（根据SmartPtr<U>创建一个SmartPtr<T>），u和v 的类型是同一个template的不同具现化，又称之为泛化（generalized）copy构造函数；

希望根据一个SmartPtr<Bottom>创建一个 SmartPtr<Top>。而不是根据SmartPtr<Top>，创建一个SmartPtr<Bottom>；也不希望SmartPtr<double>创建一个SmartPtr<int>；

get成员函数：返回智能指针（条款15）所持有的原始指针的副本；

在“构造模板”实现代码中约束转换行为：

```c++
template<typename T>
class SmartPtr{
public:
	template<typename U>
	SmartPtr(const SmartPtr<U>& other)	//以other的heldPtr
		:heldPtr(other.get()){...}		//初始化this的heldPtr
	T* get() const{return heldPtr;}
	...
private:
	T* heldPtr;			//这个SmartPtr持有的内置原始指针
}；
```

下面是trl::shared_ptr的一份定义摘要：

```c++
template<class T>
class shared_ptr{
public:
	shared_ptr(shared_ptr const& r);	//copy构造函数
	template<class Y>					//泛化copy构造函数
	shared_ptr(shared_ptr<Y> const& r);
	shared_ptr& operator=(shared_ptr const& r);	//copy assigment
	template<class Y>						//泛化copy assignment
	shared_ptr& operator=(shared_ptr<Y> const& r);
	...
};
```

#### 请记住：

+ 请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数
+ 如果你声明member templates用于“泛化copy构造”or“泛化assignment操作”你还是需要声明正常的copy构造函数和copy assignment操作符；