## 条款46：需要类型转换时请为模板定义非成员函数

​		***Define non-member funcitons inside templates when type conversions are desired.***

条款24：唯有non-member函数才有能力”在所有实参身上实施隐式类型转换“

```c++
class Rational{
...
};

const Rational operator*(const Rational& lhs,const Rational& rhs)
{
	return Rational(lhs.numerator()*rhs.numerator(),
                    lhs.denominator()*rhs.denomminator());
}
```

看似无害的改动扩充：将Rational和operator*模板化：

```c++
template<typename T>
class Rational{
public:
	Rational(const T& numerator=0,const T& denominator=1);	//条款20：passed by reference
	const T numerator() const;						//条款28：返回值passed by value
	const T denominator() const;
	...
};
template<typename T>
const Rational<T> operator*(const Rational<T>& lhs,const Rational<T>& rhs)
{...}
```

令Rational<T>class声明适当的operator*为其friend函数：

```c++
template<typename T>
class Rational{
public:
	...
	friend const Rational operator*(const Rational& lhs,const Rational& rhs);
		//声明operator* 函数
};
template<typename T>
const Rational<T> operator*(const Rational<T>& lhs,const Rational<T>& rhs)
{	....	}
```

代码通过编译却无法连接；

template名称可被用来作为”template和其参数“的简略表达方式，所以在Ration<T>内我们可以只写Ration

连接器找不到就将operator*函数本体合并至其声明式内：

```c++
template<typename T>
class Rational{
public:
...
	friend const Rational operator* (const Rational& lhs,const Rational& rhs)
	{
		return Rational(lhs.numerator()*rhs.numerator(),
			lhs.denominator()*rhs.denominator());//实现码与条款24同
	}
};
```

为了让类型转换可发生在实参身上，需要一个non-member函数（条款24）；为了让这个函数被自动具现化，需将它声明在class内部（令它成为一个friend）

#### 请记住：

+ 当我们编写一个class template，而它所提供的”与此template相关的“函数支持”所有参数的隐式类型转换“时，请将那些函数定义为”class template内部的friend函数“