## 条款43：学习处理模板化基类内的名称

​			***Know how to access names in templatized base classes***

```c++
class CompanyA{
public:
	...
	void sendCleartext(const std::string& msg);
	void sendEncrypted(const std::string& msg);
	...
};
class CompanyB{
public:
	...
	void sendCleartext(const std::string& msg);
	void sendEncrypted(const std::string& msg);
	...
};
....		//针对其他公司设计的classes
class MsgInfo{...};		//这个class用来保存信息，以备将来产生信息；
template<typename Company>
class MsgSender{
public:
	...		//构造函数、析构函数等等
	void sendClear(const MsgInfo& info)
	{
		std::string msg;
		在这儿，根据info产生信息；
		Company c;
		c.sendCleartext(msg);
	}
	void sendSecret(const MsgInfo& info)
	{	...		}
};
```

假设又想要送出信息时志记（log）某些信息：

```c++
template<typename Company>
class LoggingMsgSender:public MsgSender<Company>{
public:
	...
	void sendClearMsg(const MsgInfo& info)
	{
		将“传送前”的信息写至log；
		sendClear(info);
		将“传送后”的信息写至log；
	}
	...
};
```

在此之中，sendClear无法识别到，因为编译器遇到**class template** LoggingMsgSender定义式时，不知道继承的是什么样的class。虽说是MsgSender<Company>，但其中的Company是个termplate参数。所以就不知道有sendClear函数；

假设有：

```c++
class CompanyZ{		//这个class不提供sendCleartext函数
public:
	...
	void sendEncrypted(const std::string& msg);
	...
};
```

一般化的MsgSender template对CompanyZ并不适用，所以要针对CompanyZ产生一个MsgSender特花版：

```c++
template<>
class MsgSender<Company>{	//一个全特化的MsgSender;他和一般template相同，
public:								//差别只在于它删除了sendClear；
	...
	void sendSecret(const MsgInfo& info)
	{...}
};
```

最前头的"template<>"语法象征既不是template也不是标准class，而是个特化版的MsgSender **template**；一旦类型参数被定义为CompanyZ，则再没有其他template参数可供变化；

#### 请记住：

+ 可在derived class templates内通过“this->”指涉base class templates内的成员名称，或借由一个明白写出的“base class资格修饰符”完成；